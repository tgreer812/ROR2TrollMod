# How to Hook Methods in Risk of Rain 2 Mods

This guide explains how to use MonoMod hooks in Risk of Rain 2 modding, which is the preferred method over Harmony in the RoR2 community.

## Prerequisites

1. **MMHOOK_RoR2.dll** - This is generated by HookGenPatcher and provides the `On` and `IL` namespaces
   - If using R2Modman: Launch game with "Start modded", find at `%appdata%\r2modmanPlus-local\RiskOfRain2\profiles\<YOUR_PROFILE>\BepInEx\plugins\MMHOOK\MMHOOK_RoR2.dll`
   - Or add package reference: `<PackageReference Include="MMHOOK.RoR2" Version="2025.6.3" NoWarn="NU1701" />`

2. **Add the On namespace**: `using On;`

## Basic Hook Pattern

### 1. Hook Registration (in your main plugin class)

```csharp
public class ExamplePlugin : BaseUnityPlugin
{
    private void OnEnable()
    {
        // Register hooks here
        On.RoR2.HealthComponent.TakeDamage += HealthComponent_TakeDamage;
    }

    private void OnDisable()
    {
        // Unregister hooks here to prevent memory leaks
        On.RoR2.HealthComponent.TakeDamage -= HealthComponent_TakeDamage;
    }
}
```

### 2. Hook Method Implementation

```csharp
private static void HealthComponent_TakeDamage(On.RoR2.HealthComponent.orig_TakeDamage orig, HealthComponent self, DamageInfo damageInfo)
{
    // PREHOOK: Code here runs BEFORE the original method
    
    orig(self, damageInfo); // Call the original method
    
    // POSTHOOK: Code here runs AFTER the original method
    if (self.body && self.body.isPlayerControlled)
    {
        Log.Info($"Player took {damageInfo.damage} damage!");
    }
}
```

## Key Points

- **Always call `orig()`** - Failing to do so prevents the original method and other mods' hooks from executing
- **Use OnEnable/OnDisable** - Not Awake() for hook registration
- **Hook chaining follows LIFO** - Last registered hook runs first: `Vanilla -> Mod A -> Mod B -> Mod C` becomes `C() -> B() -> A() -> Vanilla`
- **Hooks affect ALL instances** - Not bound to specific object instances
- **Static methods** - Hook methods should be static and match the original method signature

## Hook Method Signature Pattern

```csharp
private static ReturnType MethodName_Hook(
    On.Namespace.ClassName.orig_MethodName orig,  // Always first parameter
    ClassName self,                               // Instance (omit for static methods)
    /* ...original method parameters... */
)
```

## Scalable Organization Pattern

As your mod grows, putting all hooks in one file becomes unwieldy. Here's a suggested organization pattern:

### Option 1: Hook Classes (Recommended)

Create separate static classes for different areas of functionality:

```
ExamplePlugin/
├── ExamplePlugin.cs           // Main plugin class
├── Hooks/
│   ├── PlayerHooks.cs         // Player-related hooks
│   ├── ItemHooks.cs           // Item-related hooks
│   ├── DamageHooks.cs         // Damage/combat hooks
│   └── UIHooks.cs             // UI-related hooks
```

**ExamplePlugin.cs** (main class):
```csharp
public class ExamplePlugin : BaseUnityPlugin
{
    private void OnEnable()
    {
        PlayerHooks.Enable();
        ItemHooks.Enable();
        DamageHooks.Enable();
    }

    private void OnDisable()
    {
        PlayerHooks.Disable();
        ItemHooks.Disable();
        DamageHooks.Disable();
    }
}
```

**Hooks/DamageHooks.cs**:
```csharp
namespace ExamplePlugin.Hooks
{
    internal static class DamageHooks
    {
        internal static void Enable()
        {
            On.RoR2.HealthComponent.TakeDamage += HealthComponent_TakeDamage;
        }

        internal static void Disable()
        {
            On.RoR2.HealthComponent.TakeDamage -= HealthComponent_TakeDamage;
        }

        private static void HealthComponent_TakeDamage(On.RoR2.HealthComponent.orig_TakeDamage orig, HealthComponent self, DamageInfo damageInfo)
        {
            orig(self, damageInfo);
            
            if (self.body && self.body.isPlayerControlled)
            {
                Log.Info($"Player took {damageInfo.damage} damage!");
            }
        }
    }
}
```

### Option 2: Feature-Based Classes

Organize by specific mod features rather than game systems:

```
ExamplePlugin/
├── ExamplePlugin.cs
├── Features/
│   ├── ItemPickerFeature.cs
│   ├── DamageLoggerFeature.cs
│   └── CustomDropsFeature.cs
```

Each feature class manages its own hooks and can be enabled/disabled independently.

## Advanced Techniques

### Parameter Interception (Prehook)
```csharp
private static void CreatePickupDroplet_Hook(On.RoR2.PickupDropletController.orig_CreatePickupDroplet orig, PickupIndex pickupIndex, Vector3 position, Vector3 velocity)
{
    // Intercept and modify parameters before calling original
    if (pickupIndex == PickupCatalog.FindPickupIndex("LunarCoin.Coin0"))
    {
        pickupIndex = PickupCatalog.FindPickupIndex(ItemIndex.Hoof); // Replace lunar coins with hooves
    }
    
    orig(pickupIndex, position, velocity);
}
```

### Return Value Modification
```csharp
private static int GetItemCount_Hook(On.RoR2.Inventory.orig_GetItemCount orig, Inventory self, ItemDef itemDef)
{
    int originalCount = orig(self, itemDef);
    
    // Double all item counts for players
    if (self.GetComponent<CharacterMaster>()?.body?.isPlayerControlled == true)
    {
        return originalCount * 2;
    }
    
    return originalCount;
}
```

## IL Hooks (Advanced)

For modifying specific parts of methods without replacing the entire method, use IL hooks. These require understanding of CIL (Common Intermediate Language) and are more complex.

See the [official RoR2 wiki IL Hook guide](https://risk-of-thunder.github.io/R2Wiki/Mod-Creation/C%23-Programming/Il-line-finding-and-general-Il-editing/) for details.

## Best Practices

1. **Always unregister hooks** in OnDisable() to prevent memory leaks
2. **Call orig()** unless you specifically want to replace the method entirely
3. **Use descriptive hook method names** following the pattern `ClassName_MethodName`
4. **Group related hooks** into logical classes/files
5. **Test hook interactions** with other mods
6. **Document complex hooks** with comments explaining what they do
7. **Consider IL hooks** for small method modifications instead of replacing entire methods

## Common Gotchas

- **Static vs Instance Methods**: Static methods don't have a `self` parameter
- **Method Overloads**: Use specific parameter types if multiple overloads exist
- **Null Checks**: Always check for null before accessing properties (e.g., `self.body`)
- **Performance**: Hooks run frequently, so keep them lightweight
- **Load Order**: Remember that hooks follow LIFO ordering with other mods
